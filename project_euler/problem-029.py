# -*- coding: utf-8 -*-
"""
Distinct powers:
Problem 29
Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
"""

def primes_eratosthenes(goal):
    nums = range(0, goal + 1)
    for num in nums[2:]:
        if not num == 0:
            prime = num
            idx = 2 * prime
            while idx < goal + 1:
                nums[idx] = 0
                idx += prime
    primes = [prime for prime in nums[2:] if not prime == 0]
    return primes

primes_list = primes_eratosthenes(100)

def factorized(number):
    global primes_list
    factorized_number = []
    while number > 1:
        for prime in primes_list:
            if not number % prime:
                number /= prime
                power = 1
                while number % prime == 0: 
                    number /= prime
                    power += 1
                factorized_number.append((prime, power))
                  
    return factorized_number


def powered(factorized_number, power):
    new_factorized_number = []
    for factor_power in factorized_number:
        new_factorized_number.append((factor_power[0], factor_power[1] * power))
    return new_factorized_number
        

seq = set([])

for base in range(2,101):
    for power in range (2,101):
        seq.add(tuple(sorted(powered(factorized(base), power))))

print len(seq)
        